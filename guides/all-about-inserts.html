<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All About Inserts - diesel.rs</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to diesel.rs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">About Diesel</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="../guides/index.html"><strong aria-hidden="true">1.</strong> Guides to Diesel</a></li><li class="chapter-item expanded "><a href="../guides/getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="../guides/all-about-updates.html"><strong aria-hidden="true">3.</strong> All About Updates</a></li><li class="chapter-item expanded "><a href="../guides/all-about-inserts.html" class="active"><strong aria-hidden="true">4.</strong> All About Inserts</a></li><li class="chapter-item expanded "><a href="../guides/composing-applications.html"><strong aria-hidden="true">5.</strong> Composing Applications with Diesel</a></li><li class="chapter-item expanded "><a href="../guides/schema-in-depth.html"><strong aria-hidden="true">6.</strong> Schema in Depth</a></li><li class="chapter-item expanded "><a href="../guides/extending-diesel.html"><strong aria-hidden="true">7.</strong> Extending Diesel</a></li><li class="chapter-item expanded "><a href="../guides/configuring-diesel-cli.html"><strong aria-hidden="true">8.</strong> Configuring Diesel CLI</a></li><li class="chapter-item expanded affix "><li class="part-title">Docs</li><li class="chapter-item expanded "><a href="../docs/index.html"><strong aria-hidden="true">9.</strong> API documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">diesel.rs</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/diesel-rs/diesel" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="all-about-inserts"><a class="header" href="#all-about-inserts">All About Inserts</a></h1>
<p>Most applications fall into a category called &quot;CRUD&quot; apps.
CRUD stands for &quot;Create, Read, Update, Delete&quot;.
Diesel provides support for all four pieces,
but in this guide we're going to look at
the different ways to go about creating <code>INSERT</code> statements.</p>
<p>The examples for this guide are going to be shown for PostgreSQL,
but you can follow along with any backend.
The full code examples for all backends are linked at the bottom of this guide.</p>
<p>An insert statement always starts with <a href="https://docs.diesel.rs/diesel/fn.insert_into.html"><code>insert_into</code></a>.
The first argument to this function is the table you're inserting into.</p>
<p>For this guide, our schema will look like this:</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L16-L26">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    users {
        id -&gt; Integer,
        name -&gt; Text,
        hair_color -&gt; Nullable&lt;Text&gt;,
        created_at -&gt; Timestamp,
        updated_at -&gt; Timestamp,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Since our functions are going to only operate on the <code>users</code> table,
we can put <code>use schema::users::dsl::*;</code> at the top of our function,
which will let us write <code>insert_into(users)</code> instead of
<code>insert_into(users::table)</code>.
If you're importing <code>table::dsl::*</code>,
make sure it's always inside a function, not the top of your module.</p>
<p>If all of the columns on a table have a default,
the simplest thing we can do is call <a href="https://docs.diesel.rs/diesel/query_builder/insert_statement/struct.IncompleteInsertStatement.html#method.default_values"><code>.default_values</code></a>.
We could write a function that ran that query like this:</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L47-L49">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users).default_values().execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>It's worth noting that this code will still compile,
even if you don't have default values on all of your columns.
Diesel will ensure that the value you're assigning has the right type,
but it can't validate whether the column has a default,
any constraints that could fail,
or any triggers that could fire.</p>
<p>We can use <a href="https://docs.diesel.rs/diesel/fn.debug_query.html"><code>debug_query</code></a> to inspect the generated SQL.
The exact SQL that is generated may differ depending on the backend you're using.
If we run <code>println!(&quot;{}&quot;, debug_query::&lt;Pg, _&gt;(&amp;our_query));</code>,
we'll see the following:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L57">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; DEFAULT VALUES -- binds: []
</code></pre>
<p>If we want to actually provide values, we can call <a href="https://docs.diesel.rs/diesel/query_builder/insert_statement/struct.IncompleteInsertStatement.html#method.values"><code>.values</code></a> instead.
There are a lot of different arguments we can provide here.
The simplest is a single column/value pair using <a href="https://docs.diesel.rs/diesel/expression_methods/trait.ExpressionMethods.html#method.eq"><code>.eq</code></a>.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L62-L64">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users).values(name.eq(&quot;Sean&quot;)).execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L72-L73">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;) VALUES ($1)
-- binds [&quot;Sean&quot;]
</code></pre>
<p>If we want to provide values for more than one column, we can pass a tuple.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L80-L82">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>insert_into(users)
    .values((name.eq(&quot;Tess&quot;), hair_color.eq(&quot;Brown&quot;)))
    .execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L90-L91">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, $2) -- binds: [&quot;Tess&quot;, &quot;Brown&quot;]
</code></pre>
<h2 id="insertable"><a class="header" href="#insertable">Insertable</a></h2>
<p>Working with tuples is the typical way to do an insert
if you just have some values that you want to stick in the database.
But what if your data is coming from another source,
like a web form deserialized by Serde?
It'd be annoying to have to write
<code>(name.eq(user.name), hair_color.eq(user.hair_color))</code>.</p>
<p>Diesel provides the <a href="https://docs.diesel.rs/diesel/prelude/trait.Insertable.html"><code>Insertable</code></a> trait for this case.
<code>Insertable</code> maps your struct to columns in the database.
We can derive this automatically by adding <code>#[derive(Insertable)]</code> to our type.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L30-L35">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users;

#[derive(Deserialize, Insertable)]
#[table_name = &quot;users&quot;]
pub struct UserForm&lt;'a&gt; {
    name: &amp;'a str,
    hair_color: Option&lt;&amp;'a str&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L98-L103">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

let json = r#&quot;{ &quot;name&quot;: &quot;Sean&quot;, &quot;hair_color&quot;: &quot;Black&quot; }&quot;#;
let user_form = serde_json::from_str::&lt;UserForm&gt;(json)?;

insert_into(users).values(&amp;user_form).execute(conn)?;

Ok(())
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the same SQL as if we had used a tuple.</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L113-L114">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, $2) -- binds: [&quot;Sean&quot;, &quot;Black&quot;]
</code></pre>
<p>If one of the fields is <code>None</code>, the default value will be inserted for that field.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L119-L126">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

let json = r#&quot;{ &quot;name&quot;: &quot;Ruby&quot;, &quot;hair_color&quot;: null }&quot;#;
let user_form = serde_json::from_str::&lt;UserForm&gt;(json)?;

insert_into(users).values(&amp;user_form).execute(conn)?;

Ok(())
<span class="boring">}
</span></code></pre></pre>
<p>That will generate the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L136-L137">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, DEFAULT) -- binds: [&quot;Ruby&quot;]
</code></pre>
<h2 id="batch-insert"><a class="header" href="#batch-insert">Batch Insert</a></h2>
<p>If we want to insert more than one row at a time,
we can do that by passing a <code>&amp;Vec</code> or slice of any of the forms used above.
Keep in mind that you're always passing a reference here.
As of Diesel 1.0, Rust will generate a very opaque error message about
overflow if you try to pass <code>Vec</code> instead of <code>&amp;Vec</code>.</p>
<p>On backends that support the <code>DEFAULT</code> keyword (all backends except SQLite),
the data will be inserted in a single query.
On SQLite, one query will be performed per row.</p>
<p>For example, if we wanted to insert two rows with a single value,
we can just use a <code>Vec</code>.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L142-L146">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users)
    .values(&amp;vec![name.eq(&quot;Sean&quot;), name.eq(&quot;Tess&quot;)])
    .execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>Which generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L155-L156">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;) VALUES ($1), ($2)
-- binds [&quot;Sean&quot;, &quot;Tess&quot;]
</code></pre>
<p>Note that on SQLite, you won't be able to use <code>debug_query</code> for this,
since it doesn't map to a single query. You can inspect each row like this:</p>
<p>src/lib.rs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for row in &amp;values {
    let query = insert_into(users).values(row);
    println!(&quot;{}&quot;, debug_query::&lt;Sqlite, _&gt;(&amp;query));
}
<span class="boring">}
</span></code></pre></pre>
<p>If we wanted to use <code>DEFAULT</code> for some of our rows, we can use an option here.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L161-L165">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users)
    .values(&amp;vec![Some(name.eq(&quot;Sean&quot;)), None])
    .execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>Note that the type here is <code>Option&lt;Eq&lt;Column, Value&gt;&gt;</code> not <code>Eq&lt;Column, Option&lt;Value&gt;&gt;</code>.
Doing <code>column.eq(None)</code> would insert <code>NULL</code> not <code>DEFAULT</code>.
This generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L174-L175">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;) VALUES ($1), (DEFAULT)
-- binds [&quot;Sean&quot;]
</code></pre>
<p>We can do the same thing with tuples.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L180-L187">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users)
    .values(&amp;vec![
        (name.eq(&quot;Sean&quot;), hair_color.eq(&quot;Black&quot;)),
        (name.eq(&quot;Tess&quot;), hair_color.eq(&quot;Brown&quot;)),
    ])
    .execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>Which generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L199-L201">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, $2), ($3, $4)
-- binds: [&quot;Sean&quot;, &quot;Black&quot;, &quot;Tess&quot;, &quot;Brown&quot;]
</code></pre>
<p>Once again, we can use an <code>Option</code> for any of the fields to insert <code>DEFAULT</code>.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L206-L213">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users)
    .values(&amp;vec![
        (name.eq(&quot;Sean&quot;), Some(hair_color.eq(&quot;Black&quot;))),
        (name.eq(&quot;Ruby&quot;), None),
    ])
    .execute(conn)
<span class="boring">}
</span></code></pre></pre>
<p>Which generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L225-L227">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, $2), ($3, DEFAULT)
-- binds: [&quot;Sean&quot;, &quot;Black&quot;, &quot;Ruby&quot;]
</code></pre>
<p>Finally, <code>Insertable</code> structs can be used for batch insert as well.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L232-L242">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

let json = r#&quot;[
    { &quot;name&quot;: &quot;Sean&quot;, &quot;hair_color&quot;: &quot;Black&quot; },
    { &quot;name&quot;: &quot;Tess&quot;, &quot;hair_color&quot;: &quot;Brown&quot; }
]&quot;#;
let user_form = serde_json::from_str::&lt;Vec&lt;UserForm&gt;&gt;(json)?;

insert_into(users).values(&amp;user_form).execute(conn)?;

Ok(())
<span class="boring">}
</span></code></pre></pre>
<p>This generates the same SQL as if we had used a tuple:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L225-L227">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;hair_color&quot;)
VALUES ($1, $2), ($3, $4)
-- binds: [&quot;Sean&quot;, &quot;Black&quot;, &quot;Tess&quot;, &quot;Brown&quot;]
</code></pre>
<h2 id="the-returning-clause"><a class="header" href="#the-returning-clause">The <code>RETURNING</code> Clause</a></h2>
<p>On backends that support the <code>RETURNING</code> clause (such as PostgreSQL),
we can get data back from our insert as well.
MySQL and SQLite do not support <code>RETURNING</code> clauses.
To get back all of the inserted rows,
we can call <a href="https://docs.diesel.rs/diesel/query_dsl/trait.RunQueryDsl.html#method.get_results"><code>.get_results</code></a> instead of <a href="https://docs.diesel.rs/diesel/query_dsl/trait.RunQueryDsl.html#method.execute"><code>.execute</code></a>.</p>
<p>Given this struct:</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L37-L44">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Queryable, PartialEq, Debug)]
struct User {
    id: i32,
    name: String,
    hair_color: Option&lt;String&gt;,
    created_at: SystemTime,
    updated_at: SystemTime,
}
<span class="boring">}
</span></code></pre></pre>
<p>We can use <code>get_results</code> with this test:</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L265-L295">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::select;
use schema::users::dsl::*;

let now = select(diesel::dsl::now).get_result::&lt;SystemTime&gt;(&amp;conn)?;

let inserted_users = insert_into(users)
    .values(&amp;vec![
        (id.eq(1), name.eq(&quot;Sean&quot;)),
        (id.eq(2), name.eq(&quot;Tess&quot;)),
    ])
    .get_results(&amp;conn)?;

let expected_users = vec![
    User {
        id: 1,
        name: &quot;Sean&quot;.into(),
        hair_color: None,
        created_at: now,
        updated_at: now,
    },
    User {
        id: 2,
        name: &quot;Tess&quot;.into(),
        hair_color: None,
        created_at: now,
        updated_at: now,
    },
];
assert_eq!(expected_users, inserted_users);
<span class="boring">}
</span></code></pre></pre>
<p>To inspect the SQL generated by <code>.get_results</code> or <code>.get_result</code>,
we will need to call <code>.as_query</code> before passing it to <code>debug_query</code>.
The query in the last test generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L306-L309">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;id&quot;, &quot;name&quot;)
VALUES ($1, $2), ($3, $4)
RETURNING &quot;users&quot;.&quot;id&quot;, &quot;users&quot;.&quot;name&quot;, &quot;users&quot;.&quot;hair_color&quot;,
          &quot;users&quot;.&quot;created_at&quot;, &quot;users&quot;.&quot;updated_at&quot;
-- binds: [1, &quot;Sean&quot;, 2, &quot;Tess&quot;]
</code></pre>
<p>You'll notice that we've never given an explicit value for <code>created_at</code> and
<code>updated_at</code> in any of our examples.
With Diesel, you typically won't set those values in Rust.
Typically these columns get set with <code>DEFAULT CURRENT_TIMESTAMP</code>,
and a trigger is used to change <code>updated_at</code> on updates.
If you're using PostgreSQL, you can use a built-in trigger
by running <code>SELECT diesel_manage_updated_at('users');</code> in a migration.</p>
<p>If we expect one row instead of multiple, we can call <code>.get_result</code> instead of
<code>.get_results</code>.</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L317-L335">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::select;
use schema::users::dsl::*;

let now = select(diesel::dsl::now).get_result::&lt;SystemTime&gt;(&amp;conn)?;

let inserted_user = insert_into(users)
    .values((id.eq(3), name.eq(&quot;Ruby&quot;)))
    .get_result(&amp;conn)?;

let expected_user = User {
    id: 3,
    name: &quot;Ruby&quot;.into(),
    hair_color: None,
    created_at: now,
    updated_at: now,
};
assert_eq!(expected_user, inserted_user);
<span class="boring">}
</span></code></pre></pre>
<p>This generates the same SQL as <code>get_results</code>:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L347-L350">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;id&quot;, &quot;name&quot;) VALUES ($1, $2)
RETURNING &quot;users&quot;.&quot;id&quot;, &quot;users&quot;.&quot;name&quot;, &quot;users&quot;.&quot;hair_color&quot;,
          &quot;users&quot;.&quot;created_at&quot;, &quot;users&quot;.&quot;updated_at&quot;
-- binds: [3, &quot;Ruby&quot;]
</code></pre>
<p>Finally, if we only want a single column back, we can call <code>.returning()</code> explicitly.
This code would return the inserted ID:</p>
<p>src/lib.rs (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L355-L360">view on GitHub</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use schema::users::dsl::*;

insert_into(users)
    .values(name.eq(&quot;Ruby&quot;))
    .returning(id)
    .get_result(conn)
<span class="boring">}
</span></code></pre></pre>
<p>Which generates the following SQL:</p>
<p>Generated SQL (<a href="https://github.com/diesel-rs/diesel/blob/v1.4.4/examples/postgres/all_about_inserts/src/lib.rs#L368-L370">view on GitHub</a>):</p>
<pre><code class="language-sql">INSERT INTO &quot;users&quot; (&quot;name&quot;) VALUES ($1)
RETURNING &quot;users&quot;.&quot;id&quot;
-- binds: [&quot;Ruby&quot;]
</code></pre>
<h2 id="upsert"><a class="header" href="#upsert">&quot;Upsert&quot;</a></h2>
<p>Every type of insert statement covered in this guide can also be used for
&quot;insert or update&quot; queries, also known as &quot;upsert&quot;.
The specifics of upsert are covered extensively in the API documentation.</p>
<p>For PostgreSQL, see the <a href="https://docs.diesel.rs/diesel/pg/upsert/index.html"><code>pg::upsert</code></a> module.
For MySQL and SQLite, upsert is done via <code>REPLACE</code>.
See <a href="https://docs.diesel.rs/diesel/fn.replace_into.html"><code>replace_into</code></a> for details.</p>
<p>Diesel does not have support for MySQL's <code>ON DUPLICATE KEY</code> conflict,
as its results are non-deterministic, and unsafe with replication.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>While there are a lot of examples in this guide,
ultimately the only difference between various kinds of insert statements
is the argument passed to <code>.values</code>.</p>
<p>All examples in this guide are run as part of Diesel's test suite.
You can find the full code examples for each backend at these links:</p>
<ul>
<li><a href="https://github.com/diesel-rs/diesel/tree/v1.4.4/examples/postgres/all_about_inserts">PostgreSQL</a></li>
<li><a href="https://github.com/diesel-rs/diesel/tree/v1.4.4/examples/mysql/all_about_inserts">MySQL</a></li>
<li><a href="https://github.com/diesel-rs/diesel/tree/v1.4.4/examples/sqlite/all_about_inserts">SQLite</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../guides/all-about-updates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../guides/composing-applications.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../guides/all-about-updates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../guides/composing-applications.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
